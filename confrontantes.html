<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Consulta de Indicações Fiscais de Confrontantes</title>

  <script src="lib/leaflet/leaflet.js"></script>
  <link href="lib/leaflet/leaflet.css" rel="stylesheet">
  <script src="lib/leaflet/esri-leaflet.js"></script>
  <script src="lib/leaflet/esri-leaflet-vector.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <style>
    @page { size: A4 portrait; margin: 10mm; }
    body { margin: 0; padding: 0; font-family: Arial, sans-serif; font-size: 12px; color: black; }

    .pagina {
      width: 210mm; height: 297mm; box-sizing: border-box; border: 1px solid black;
      display: flex; flex-direction: column; justify-content: space-between; page-break-after: always;
    }

    .cabecalho { border-bottom: 1px solid black; padding: 5px 8px; }
    .cabecalho-superior { display: flex; align-items: center; justify-content: space-between; font-size: 11px; }
    .cabecalho-superior img { height: 35px; }
    .titulo { text-align: center; font-weight: bold; border-bottom: 1px solid black; padding: 4px; }
    .texto { padding: 4px 8px; border-bottom: 1px solid black; font-size: 11px; }
    .rodape { border-top: 1px solid black; text-align: center; font-size: 11px; font-weight: bold; padding: 3px; }

    .areaQuadro { flex: 1; display: flex; align-items: center; justify-content: center; padding: 5px; box-sizing: border-box; }
    .quadro { display: flex; border: 1px solid #ccc; }
    .mapa { width: 160mm; height: 250mm; border-right: 1px solid #ccc; }
    .painel { width: 50mm; height: 250mm; padding: 5px; overflow-y: auto; box-sizing: border-box; }

    .tituloPainel { display: flex; align-items: center; gap: 6px; margin: 6px 0; }
    .caixaLegenda { width: 14px; height: 14px; border: 2px solid; display:inline-block; vertical-align:middle; margin-right:6px; }
    .caixaLote { background-color: darkgray; border-color: black; }
    .caixaConfrontantes { background-color: rgba(0,0,139,0.1); border-color: darkblue; }

    .loteTooltip {
      background: rgba(255,255,255,0.75) !important;
      border: 1px solid rgba(0,0,0,0.15) !important;
      box-shadow: none !important;
      font-size: 16px;
      font-weight: bold;
      color: black;
      padding: 2px 4px;
      border-radius: 2px;
    }

    .registro { border-bottom: 1px solid #ccc; margin-bottom: 6px; padding-bottom: 4px; font-size: 10px; line-height: 1.3em; }
    .registro strong { display: block; margin-bottom: 2px; }
    .legenda-mapa { position: absolute; left:8px; bottom:8px; background:#fff; padding:6px; border:1px solid #ccc; font-size:11px; }

    .invisible-marker { width:0; height:0; }
  </style>
</head>

<body>
  <div id="container"></div>

  <script>
    const urlMalha = "https://arcgis.itajai.sc.gov.br/server/rest/services/malha_cadastral_raster/FeatureServer/0";
    const urlImoveis = "https://arcgis.itajai.sc.gov.br/server/rest/services/Hosted/imoveis_plantacadastral/FeatureServer/0/";
    const MAX_VIZINHOS_POR_QUADRO = 6;

    const inscrlig = window.location.hash.length > 1 ? window.location.hash.substring(1) : null;
    if (!inscrlig) {
      alert("Adicione o número da inscrição ao final do endereço, ex: consulta.html#i005473010090");
      throw new Error("Inscrição não informada.");
    }

    L.esri.query({ url: urlMalha })
      .where(`inscrlig='${inscrlig}'`)
      .run((err, fc) => {
        if (err || !fc.features || fc.features.length === 0) {
          alert("Inscrição não encontrada na base cadastral.");
          return;
        }

        const lote = fc.features[0];
        const idLote = lote.properties.objectid;

        const bufferSmall = turf.buffer(lote, 0.5, { units: "meters" });

        L.esri.query({ url: urlMalha })
          .intersects(bufferSmall)
          .run((err2, viz) => {
            if (err2) {
              console.error("Erro consulta vizinhos:", err2);
              return;
            }

            const vizinhosAdjacentes = (viz.features || []).filter(f => {
              if (f.properties.objectid === idLote) return false;
              try { return !!turf.intersect(bufferSmall, f); } catch (e) { return false; }
            });

            if (!vizinhosAdjacentes || vizinhosAdjacentes.length === 0) {
              alert("Nenhum confrontante direto encontrado (buffer 0.5 m). A planta de confrontantes não será gerada.");
              return;
            }

            const bufferLarge = turf.buffer(lote, 10, { units: "meters" });

            function clipNeighborsByBuffer(bufferGeom, vizinhosArray) {
              const clips = [];
              for (const v of vizinhosArray) {
                try {
                  const inter = turf.intersect(bufferGeom, v);
                  if (!inter) continue;

                  let best = inter;
                  const geomType = inter.geometry && inter.geometry.type;

                  if (geomType === "MultiPolygon") {
                    let maxArea = -1;
                    let bestPoly = null;
                    inter.geometry.coordinates.forEach(coords => {
                      const poly = {
                        type: "Feature",
                        properties: { ...v.properties },
                        geometry: { type: "Polygon", coordinates: coords }
                      };
                      const a = turf.area(poly);
                      if (a > maxArea) { maxArea = a; bestPoly = poly; }
                    });
                    if (bestPoly) best = bestPoly;
                  }

                  if (best.properties == null) best.properties = {};
                  best.properties = { ...v.properties };

                  clips.push(best);
                } catch (e) {
                  console.warn("clip falhou objectid", v.properties?.objectid, e);
                }
              }
              return clips;
            }

            const clipes = clipNeighborsByBuffer(bufferLarge, vizinhosAdjacentes);
            if (!clipes || clipes.length === 0) {
              alert("Nenhum trecho de interseção resultante do buffer de 10 m. A planta de confrontantes não será gerada.");
              return;
            }

            const inscrSelecionado = lote.properties.inscrlig;
            const inscrVizinhos = vizinhosAdjacentes.map(f => `'${f.properties.inscrlig}'`).join(",");
            const inscrTodos = `'${inscrSelecionado}'` + (inscrVizinhos ? `,${inscrVizinhos}` : "");

            L.esri.query({ url: urlImoveis })
              .where(`inscrlig IN (${inscrTodos})`)
              .run((err3, fcImoveis) => {
                if (err3 || !fcImoveis.features || fcImoveis.features.length === 0) {
                  montarRelatorio(lote, vizinhosAdjacentes, {}, clipes);
                  return;
                }

                const dicContrib = {};
                const agrupados = {};
                fcImoveis.features.forEach(f => {
                  const insc = f.properties.inscrlig;
                  if (!agrupados[insc]) agrupados[insc] = [];
                  agrupados[insc].push(f.properties);
                });
                Object.keys(agrupados).forEach(insc => {
                  const registros = agrupados[insc];
                  const titularSim = registros.find(r => r.titular && r.titular.toString().trim().toUpperCase() === "SIM");
                  const selecionado = titularSim || registros[0];
                  dicContrib[insc] = selecionado?.nome_contribuinte || "-";
                });

                montarRelatorio(lote, vizinhosAdjacentes, dicContrib, clipes);
              });
          });
      });

    function ordenarVizinhosPorAngulo(loteFeat, vizinhosArray, passoGraus) {
      const centro = turf.centroid(loteFeat);
      const coordCentro = centro.geometry.coordinates;
      const lista = [];
      const ids = new Set();
      const alcance = 2000;

      for (let ang = 0; ang < 360; ang += passoGraus) {
        const destino = turf.destination(centro, alcance, ang, { units: "meters" });
        const linha = turf.lineString([coordCentro, destino.geometry.coordinates]);
        for (const v of vizinhosArray) {
          try {
            const inter = turf.lineIntersect(linha, v);
            if (inter.features && inter.features.length > 0) {
              const idv = v.properties.objectid;
              if (!ids.has(idv)) {
                lista.push(v);
                ids.add(idv);
              }
            }
          } catch (e) {}
        }
      }
      const final = [];
      const vistos = new Set();
      for (const v of lista) {
        const id = v.properties.objectid;
        if (!vistos.has(id)) {
          final.push(v);
          vistos.add(id);
        }
      }
      return final;
    }

    function getLabelPoint(feature) {
      try {
        if (!feature || !feature.geometry) throw new Error("feature inválida");
        const pt = turf.pointOnFeature(feature);
        return pt && pt.geometry && pt.geometry.coordinates ? pt.geometry.coordinates : null;
      } catch (e) {
        try { return turf.centroid(feature).geometry.coordinates; } catch (e2) { return null; }
      }
    }

    function montarRelatorio(lote, vizinhosValidos, dicContrib, clipes) {
      const listaSequencial = ordenarVizinhosPorAngulo(lote, vizinhosValidos, 1);

      const mapaClipById = {};
      (clipes || []).forEach(c => {
        const id = c.properties?.objectid ?? c.properties?.inscrlig;
        if (id != null) mapaClipById[id] = c;
      });

      const clipesSequenciais = listaSequencial.map(v => mapaClipById[v.properties.objectid] || null);

      const gruposV = [];
      const gruposC = [];
      for (let i = 0; i < listaSequencial.length; i += MAX_VIZINHOS_POR_QUADRO) {
        gruposV.push(listaSequencial.slice(i, i + MAX_VIZINHOS_POR_QUADRO));
        gruposC.push(clipesSequenciais.slice(i, i + MAX_VIZINHOS_POR_QUADRO));
      }

      if (!gruposV || gruposV.length === 0) {
        criarPagina(lote, [], dicContrib, 1, 1, false, [], true);
        return;
      }

      const singlePageMode = gruposV.length === 1;
      let contadorGlobal = 1;
      for (let i = 0; i < gruposV.length; i++) {
        const isSingle = singlePageMode; // true se somente uma prancha
        criarPagina(lote, gruposV[i], dicContrib, i + 1, contadorGlobal, false, gruposC[i], isSingle);
        contadorGlobal += gruposV[i].length;
      }

      const totalConfrontantes = listaSequencial.length;
      if (totalConfrontantes > MAX_VIZINHOS_POR_QUADRO) {
        // página final visão geral (não singlePage)
        criarPagina(lote, vizinhosValidos, dicContrib, gruposV.length + 1, null, true, clipes, false);
      }
    }

    // assinatura adicionada singlePage (boolean)
    function criarPagina(lote, vizinhosGrupo, dicContrib, indiceQuadro, contadorInicial, paginaFinal, clipesDoGrupo, singlePage) {
      const container = document.getElementById("container");
      const pagina = document.createElement("div");
      pagina.className = "pagina";
      pagina.innerHTML = `
        <div class="cabecalho">
          <div class="cabecalho-superior">
            <div><img src="https://arcgis.itajai.sc.gov.br/geoitajai/plantacadastral/images/brasao_muicipio.png" alt="Logo Itajaí" "></div>
            <div>
              <b>PREFEITURA MUNICIPAL DE ITAJAÍ - SC</b><br>
              Secretaria Municipal da Fazenda<br>
              Departamento de Cadastro Técnico
            </div>
            <div><b>Data:</b> ${new Date().toLocaleDateString("pt-BR")}</div>
          </div>
        </div>
        <div class="titulo">CONSULTA DE INDICAÇÕES FISCAIS DE CONFRONTANTES</div>
        <div class="texto">
          Consulta gerada nos termos da Ação Conjunta SEDUH - SEFAZ, nº xx/2025.<br>
          Considera os dados da base cadastral georreferenciada na data de sua emissão, disponível em:<br>
          <a href="https://plantacadastral.itajai.sc.gov.br/" target="_blank" rel="noopener noreferrer">https://plantacadastral.itajai.sc.gov.br/</a><br>
          Os dados coletados têm finalidade tributária.<br>
          O presente documento e suas informações não constituem prova ou reconhecimento de direito de propriedade.
        </div>
        <div class="rodape">CROQUI DE LOCALIZAÇÃO E CONFRONTANTES</div>
        <div class="areaQuadro" id="areaQuadro_${indiceQuadro}"></div>
      `;
      container.appendChild(pagina);

      const area = pagina.querySelector(`#areaQuadro_${indiceQuadro}`);
      const quadroDiv = document.createElement("div");
      quadroDiv.className = "quadro";

      const mapaDiv = document.createElement("div");
      mapaDiv.id = "mapa_" + indiceQuadro;
      mapaDiv.className = "mapa";

      const painelDiv = document.createElement("div");
      painelDiv.className = "painel";

      if (paginaFinal) {
        painelDiv.innerHTML = `
          <div class="tituloPainel"><div class="caixaLegenda caixaLote"></div>
          <h3 style="margin:0">Lote Selecionado</h3></div>
          <div id="loteSel_${indiceQuadro}"></div>
        `;
      } else {
        painelDiv.innerHTML = `
          <div class="tituloPainel"><div class="caixaLegenda caixaLote"></div>
          <h3 style="margin:0">Lote Selecionado</h3></div>
          <div id="loteSel_${indiceQuadro}"></div>
          <div class="tituloPainel"><div class="caixaLegenda caixaConfrontantes"></div>
          <h3 style="margin:0">Confrontantes</h3></div>
          <div id="listaVizinhos_${indiceQuadro}"></div>
        `;
      }

      quadroDiv.appendChild(mapaDiv);
      quadroDiv.appendChild(painelDiv);
      area.appendChild(quadroDiv);

      criarMapa(lote, vizinhosGrupo, dicContrib, indiceQuadro, contadorInicial, paginaFinal, clipesDoGrupo, !!singlePage);
    }

    // criarMapa agora recebe singlePage (boolean)
    function criarMapa(lote, vizinhosGrupo, dicContrib, indiceQuadro, contadorInicial, paginaFinal, clipesDoGrupo, singlePage) {
      const mapa = L.map("mapa_" + indiceQuadro, {
        attributionControl: false,
        zoomControl: false,
        dragging: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        touchZoom: false
      }).setView([-26.9046, -48.6874], 16);

      L.esri.Vector.vectorTileLayer("7a110ef9198540068341e6908c6bf298", {
        portalUrl: "https://arcgis.itajai.sc.gov.br/portal",
        attribution: "Prefeitura de Itajaí"
      }).addTo(mapa);

      const loteLayer = L.geoJSON(lote, {
        style: { color: "black", weight: 4, fillColor: "darkgray", fillOpacity: 0.5 },
        onEachFeature: (f, l) => {
          l.bindTooltip("LOTE", { permanent: true, direction: "center", className: "loteTooltip" });
        }
      }).addTo(mapa);

      let contador = contadorInicial || 1;

      const vizLayer = L.geoJSON(vizinhosGrupo, {
        style: { color: "darkblue", weight: 2, fillOpacity: 0.1 },
        onEachFeature: (f, l) => {
          // sem criar lista aqui; lista lateral será construída abaixo com numeração sincronizada
        }
      }).addTo(mapa);

      // construir lista lateral com números sincronizados (num - nome)
      if (!paginaFinal) {
        const listaEl = document.getElementById(`listaVizinhos_${indiceQuadro}`);
        if (listaEl) {
          let listaHTML = "";
          for (let i = 0; i < vizinhosGrupo.length; i++) {
            const f = vizinhosGrupo[i];
            const p = f.properties || {};
            const num = (contador || 1) + i;
            const nome = dicContrib[p.inscrlig] || "-";
            listaHTML += `
              <div class="registro">
                <strong>${num} - ${nome}</strong>
                <strong>Inscrição:</strong> ${p.inscricao || p.inscrlig || "-"}<br>
                <strong>Endereço:</strong> ${p.nomevia || "-"}, nº ${p.numero || "-"}
              </div>`;
          }
          listaEl.innerHTML = listaHTML;
        }
      }

      const loteSelEl = document.getElementById(`loteSel_${indiceQuadro}`);
      if (loteSelEl) {
        const p = lote.properties || {};
        loteSelEl.innerHTML = `
          <div class="registro">
            <strong>${dicContrib[p.inscrlig] || "-"}</strong>
            <strong>Inscrição:</strong> ${p.inscricao || p.inscrlig || "-"}<br>
            <strong>Endereço:</strong> ${p.nomevia || "-"}, nº ${p.numero || "-"}
          </div>`;
      }

      // criar marcadores invisíveis e tooltips permanentes (pointOnFeature)
      const marcadorGroup = L.featureGroup();
      if (!paginaFinal && Array.isArray(clipesDoGrupo)) {
        clipesDoGrupo.forEach((clip, idx) => {
          if (!clip) return;
          try {
            const coords = getLabelPoint(clip);
            if (!coords) return;
            const latlng = [coords[1], coords[0]];
            const num = (contador || 1) + idx;
            const marker = L.marker(latlng, {
              interactive: false,
              opacity: 0,
              icon: L.divIcon({ className: 'invisible-marker', html: '' })
            }).addTo(mapa);
            marker.bindTooltip(String(num), { permanent: true, direction: "center", className: "loteTooltip" }).openTooltip();
            marcadorGroup.addLayer(marker);
          } catch (e) {
            console.warn("erro ao criar tooltip para clip", e);
          }
        });
      }

      // enquadramento:
      // - se paginaFinal === false:
      //    - se singlePage === true: enquadrar com clipes DO GRUPO + lote selecionado
      //    - se singlePage === false: enquadrar apenas com clipesDoGrupo (multi-prancha)
      // - se paginaFinal === true: enquadrar com polígonos inteiros (comportamento visão geral)
      try {
        if (!paginaFinal) {
          if (singlePage && marcadorGroup.getLayers().length > 0) {
            // combinar lote + marcadores invisíveis
            const combined = L.featureGroup([loteLayer, marcadorGroup]);
            if (combined.getBounds && combined.getBounds().isValid()) {
              mapa.fitBounds(combined.getBounds(), { padding: [30, 30], maxZoom: 19 });
            } else if (marcadorGroup.getBounds && marcadorGroup.getBounds().isValid()) {
              mapa.fitBounds(marcadorGroup.getBounds(), { padding: [30, 30], maxZoom: 19 });
            } else if (loteLayer.getBounds && loteLayer.getBounds().isValid()) {
              mapa.fitBounds(loteLayer.getBounds(), { padding: [30,30], maxZoom: 19 });
            }
          } else {
            // multi-prancha (usar apenas clipes/marcadores)
            if (marcadorGroup.getBounds && marcadorGroup.getBounds().isValid()) {
              mapa.fitBounds(marcadorGroup.getBounds(), { padding: [30, 30], maxZoom: 19 });
            } else {
              const fallback = L.featureGroup([vizLayer]);
              if (fallback.getBounds && fallback.getBounds().isValid()) mapa.fitBounds(fallback.getBounds(), { padding: [30,30], maxZoom: 19 });
            }
          }
        } else {
          // paginaFinal: usar polígonos inteiros (lote + vizinhos)
          const groupFull = L.featureGroup([loteLayer, vizLayer]);
          if (groupFull.getBounds && groupFull.getBounds().isValid()) {
            mapa.fitBounds(groupFull.getBounds(), { padding: [30, 30], maxZoom: 19 });
          }
        }
      } catch (e) {
        console.warn("Erro ao ajustar bounds:", e);
      }

      const norte = L.control({ position: 'topright' });
      norte.onAdd = () => {
        const div = L.DomUtil.create('div', 'info2 legend');
        div.innerHTML = '<center><sub><font size="6">▲</font></sub><br/><sup><font size="4">N</font></sup></center>';
        return div;
      };
      norte.addTo(mapa);

      setTimeout(() => { try { mapa.invalidateSize(); } catch (e){} }, 200);
    }
  </script>
</body>
</html>
